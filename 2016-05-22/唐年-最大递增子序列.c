//1.问题描述
//有子序列{2，1 ，5 ，3 ，6，4， 8 ，9，7}这样一个字符串的的最长递增子序列就是 {1,3,4,8,9}
//
//2.思路分析
//一种非常简单的方法就是假设我们的初始的序列S1。那我们从小到大先排序一下。得到了S1'。
//这样我们再球 S1和S1'的最长公共子序列就可以知道答案了是不是有点巧妙啊。
//嗯，感觉可以喝杯咖啡了，然而，O(n2)的时间复杂度你能忍么，忍不了忍不了，继续优化。
//我们定义一个序列B，然后令 i = 1 到 9 逐个考察这个序列。此外，我们用一个变量Len来记录现在最长算到多少了。
//首先，把d[1]有序地放到B里，令B[1] = 2，就是说当只有1一个数字2的时候，长度为1的LIS的最小末尾是2。这时Len=1；
//然后，把d[2]有序地放到B里，令B[1] = 1，就是说长度为1的LIS的最小末尾是1，d[1]=2已经没用了，很容易理解吧。这时Len=1；
//接着，d[3] = 5，d[3]>B[1]，所以令B[1+1]=B[2]=d[3]=5，就是说长度为2的LIS的最小末尾是5，
//很容易理解吧。这时候B[1..2] = 1, 5，Len＝2；
//再来，d[4] = 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，
//这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候B[1..2] = 1, 3，Len = 2；
//继续，d[5] = 6，它在3后面，因为B[2] = 3, 而6在3后面，于是很容易可以推知B[3] = 6, 这时B[1..3] = 1, 3, 6，
//还是很容易理解吧？ Len = 3；
//第6个, d[6] = 4，你看它在3和6之间，于是我们就可以把6替换掉，得到B[3] = 4。B[1..3] = 1, 3, 4， Len继续等于3；
//第7个, d[7] = 8，它很大，比4大，嗯。于是B[4] = 8。Len变成4了
//第8个, d[8] = 9，得到B[5] = 9，嗯。Len继续增大，到5了；
//最后一个, d[9] = 7，它在B[3] = 4和B[4] = 8之间，所以我们知道，最新的B[4] =7，B[1..5] = 1, 3, 4, 7, 9，Len = 5。
//于是我们知道了LIS的长度为5。
//
//注意，这个1,3,4,7,9不是最长递增子序列，它只是存储的对应长度LIS的最小末尾。
//有了这个末尾，我们就可以一个一个地插入数据。虽然最后一个d[9] = 7更新进去对于这组数据没有什么意义，
//但是如果后面再出现两个数字 8 和 9，那么就可以把8更新到d[5], 9更新到d[6]，得出LIS的长度为6。
//然后应该发现一件事情了：在B中插入数据是有序的，而且是进行替换而不需要挪动——也就是说，我们可以使用二分查找，
//将每一个数字的插入时间优化到O(logN)， 于是算法的时间复杂度就降低到了O(NlogN)～！嗯，可以喝咖啡了。

#include <stdio.h>
#define MAXSIZE 1024

int GetMaxLength(int *p, int n);

int FindValue(int *p, int value, int n);

int main(int argc, const char * argv[]) {
    
    int lcs[] = {2, 1, 3, 0, 4, 1, 5, 2, 7};
    int n = sizeof(lcs) / sizeof(lcs[0]);
    
    printf("最长递增子序列的长度为: %d\n", GetMaxLength(lcs, n));
    
    return 0;
}

int GetMaxLength(int *p, int n) {
    
    int L[MAXSIZE];
    //记录最长递增子序列的长度
    int k = 0;
    int i, pos;
    
    L[0] = p[0];
    
    for (i = 1; i < n; i++) {
        pos = FindValue(L, p[i], k);
        L[pos] = p[i];
        
        if (pos + 1 > k) {
            k++;
        }
    }
    
    return k;
}

//采用二分法查找值
int FindValue(int *p, int value, int n) {
    int left = 0;
    int right = n-1;
    int mid;
    while (left <= right) {
        mid = (left + right) / 2;
        if (p[mid] <= value) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return left;
}
